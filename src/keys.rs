use base64::{engine::general_purpose, Engine as _};
use ring::rand;
use ring::signature::{self, Ed25519KeyPair, KeyPair};
use serde::{Deserialize, Serialize};

/// Represents an Ed25519 key pair
///
/// An instance of `Keys` contains a `private_key` field and
/// a `public_key` field for the purpose of generating and verifying
/// digital signatures.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct Keys {
    private_key: String,
    public_key: String,
}

impl Keys {
    pub fn new_key_pair() -> Self {
        let rng = rand::SystemRandom::new();
        let pkcs8_bytes = signature::Ed25519KeyPair::generate_pkcs8(&rng)
            .expect("error: unable to generate agent keys\n");
        let key_pair = signature::Ed25519KeyPair::from_pkcs8(pkcs8_bytes.as_ref())
            .expect("error: unable to generate agent keys\n");

        let private_key = general_purpose::STANDARD.encode(pkcs8_bytes.as_ref());
        let public_key = general_purpose::STANDARD.encode(key_pair.public_key().as_ref());

        Keys {
            private_key,
            public_key,
        }
    }

    pub fn get_public_key(&self) -> &str {
        &self.public_key
    }
}

// ******************************************************************************************
// ************************************* UNIT TESTS *****************************************
// ******************************************************************************************

#[cfg(test)]
mod tests {
    use super::*;

    // Test if the generated key pair can be decoded from base64 and used
    // to generate valid signatures
    #[test]
    fn test_key_pair_signing() {
        // Generate a new keypair and store it base64-encoded in the `Keys` struct
        let keys = Keys::new_key_pair();

        // Decode the key from base64 to bytes
        let private_key_bytes = general_purpose::STANDARD
            .decode(keys.private_key)
            .expect("error: failed to decode private key from base64");

        let public_key_bytes = general_purpose::STANDARD
            .decode(keys.public_key)
            .expect("error: failed to decode public key from base64");

        // Reconstruct the key pair from the pkcs8 bytes representation
        let key_pair = signature::Ed25519KeyPair::from_pkcs8(&private_key_bytes.as_ref())
            .expect("error: unable to construct key pair");

        // Reconstruct the public key from the public key bytes
        let public_key = signature::UnparsedPublicKey::new(&signature::ED25519, public_key_bytes);

        let message = b"Tis but a scratch!";

        // Generate a signature of `message`
        let sig = key_pair.sign(message);

        // Verify if `sig` is a valid signature of `message`, i.e, verifies
        // if the signature was generated by the private key that matches `public_key`
        public_key
            .verify(message, sig.as_ref())
            .expect("error: not a valid signature of the message");
    }

    // Test if the keys are unique, i.e, they are not using the same source of entropy
    #[test]
    fn test_key_pair_collision() {
        let keys1 = Keys::new_key_pair();
        let keys2 = Keys::new_key_pair();

        assert_ne!(keys1.private_key, keys2.private_key);
        assert_ne!(keys1.public_key, keys2.public_key);
    }
}
